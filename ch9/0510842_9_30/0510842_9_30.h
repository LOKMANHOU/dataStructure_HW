/*	Data Structures for heap ADT	   Created by:	   Date:*/#ifndef _0510842_9_30#define _0510842_9_30#include <stdlib.h>#include <math.h>#include <stdbool.h>struct HEAP{   void** heapAry;   int    last;   int    size;   int    (*compare) (void* argu1, void* argu2);   int    maxSize;} ;//	Prototype Definitions struct HEAP* heapCreate (int maxSize,            int (*compare) (void* arg1, void* arg2));bool  heapInsert  (struct HEAP* heap, void*  dataPtr, int *count);bool  heapDelete  (struct HEAP* heap, void** dataOutPtr, int *count);int   heapCount   (struct HEAP* heap);bool  heapFull    (struct HEAP* heap);bool  heapEmpty   (struct HEAP* heap);void  heapDestroy (struct HEAP* heap);static void _reheapUp   (struct HEAP* heap, int childLoc, int *count);static void _reheapDown (struct HEAP* heap, int root, int *count);/*	==================== heapCreate ====================	Allocates memory for heap and returns address of	heap head structure.	   Pre  Nothing	   Post heap created and address returned	             if memory overflow, NULL returned*/struct HEAP* heapCreate (int maxSize,                  int  (*compare) (void* argu1, void* argu2)){//	Local Definitions	struct HEAP* heap;//	Statements 	heap = (struct HEAP*)malloc(sizeof (struct HEAP));	if (!heap)	   return NULL;	heap->last    = -1;	heap->compare = compare;	// Force heap size to power of 2 -1	heap->maxSize = (int) pow (2, ceil(log2(maxSize))) - 1;	heap->heapAry = (void**) 	                 calloc(heap->maxSize, sizeof(void*));	return heap;}	// createHeap /*	================== heapInsert =================== 	Inserts data into heap.	   Pre    Heap is a valid heap structure	          last is pointer to index for last element	          data is data to be inserted	   Post   data have been inserted into heap	   Return true if successful; false if array full*/bool heapInsert (struct HEAP* heap, void* dataPtr, int *count){//	Statements 	if (heap->size == 0)                 // Heap empty	   {	    heap->size                = 1;	    heap->last                = 0;	    heap->heapAry[heap->last] = dataPtr;	    return true;	   } // if	if (heap->last == heap->maxSize - 1)	  return false;	++(heap->last); 	++(heap->size);	heap->heapAry[heap->last] = dataPtr;	_reheapUp (heap, heap->last, count);	return true;}	// heapInsert /*	==================== reheapUp ====================	Reestablishes heap by moving data in child up to	correct location heap array.	   Pre  heap is array containing an invalid heap	        newNode is index to new data in heap	   Post newNode inserted into heap*/void  _reheapUp  (struct HEAP* heap, int childLoc, int *count){//	Local Definitions 	int    parent;	void** heapAry;	void*  hold;//	Statements 	// if not at root of heap -- index 0 	if (childLoc)	   {	   	(*count)++;	    heapAry = heap->heapAry;	    parent = (childLoc - 1)/ 2;	    if (heap->compare(heapAry[childLoc], 	                      heapAry[parent]) > 0)	        // child is greater than parent -- swap 	        {	         hold             = heapAry[parent]; 	         heapAry[parent]  = heapAry[childLoc];	         heapAry[childLoc] = hold;	        _reheapUp (heap, parent, count);	       } // if heap[] 	   } // if newNode 	return;}	// reheapUp /*	 ================== heapDelete ===================	Deletes root of heap and passes data back to caller.	   Pre    heap is a valid heap structure 	          last is reference to last node in heap 	          dataOut is reference to output area	   Post   last deleeted and heap rebuilt	          deleted data passed back to user	   Return true if successful; false if array empty*/bool heapDelete (struct HEAP* heap, void** dataOutPtr, int *count){//	Statements 	//printf("count:%d\n",*count);	if (heap->size == 0)	    // heap empty 	    return false;	*dataOutPtr = heap->heapAry[0];	heap->heapAry[0]  = heap->heapAry[heap->last];	(heap->last)--;	(heap->size)--;	_reheapDown (heap, 0, count);	return true;}	// heapDelete /*	=================== reheapDown =================== 	Reestablishes heap by moving data in root down to its	correct location in the heap.	   Pre  heap is array of data	        root is root of heap or subheap	        last is an index to last element in heap	   Post heap has been restored*/void _reheapDown (struct HEAP* heap, int root, int *count){//	Local Definitions 	void* hold;	void* leftData;	void* rightData;	int   largeLoc;	int   last;	//	Statements 	last = heap->last;	if ((root * 2 + 1) <= last)         // left subtree	    // There is at least one child 	   {	   	(*count)++;	    leftData   = heap->heapAry[root * 2 + 1];	    if ((root * 2 + 2) <= last)  // right subtree 	       rightData = heap->heapAry[root * 2 + 2];	    else	       rightData = NULL;	       	    // Determine which child is larger 	    if ((!rightData) 	         || heap->compare (leftData, rightData) > 0)	       {	        largeLoc = root * 2 + 1;	       } // if no right key or leftKey greater	    else	       {	        largeLoc = root * 2 + 2;	       } // else 	    // Test if root > larger subtree 	    if (heap->compare (heap->heapAry[root], 	        heap->heapAry[largeLoc]) < 0)	        {	         // parent < children 	         hold                = heap->heapAry[root]; 	         heap->heapAry[root] = heap->heapAry[largeLoc];	         heap->heapAry[largeLoc] = hold;	         _reheapDown (heap, largeLoc, count);	        } // if root < 	} // if root 	return;}	// reheapDown void heapDestroy (struct HEAP* heap){	if(heap){		int i;		for(i = 0; i < heap->maxSize; i++)			free(heap->heapAry[i]);	}	free(heap);}#endif