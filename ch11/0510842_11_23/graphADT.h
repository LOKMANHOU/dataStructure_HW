#include "queueADT.h"#include "stackADT.h"#include "stdbool.h"#include "limits.h" #include "stdio.h"#include <string.h>typedef struct{    int            count;     struct vertex* first;     int (*compare) (void* argu1, void* argu2); } GRAPH;typedef struct vertex{	 struct vertex*  pNextVertex;	 void*           dataPtr;	 int             inDegree;	 int             outDegree;	 short           processed;	 struct arc*     pArc;	 int pathLength; //extra addition !!	 bool inTree; //extra addition !!} VERTEX;typedef struct arc{	 struct vertex*  destination;	 struct arc*     pNextArc;	 int cost; //extra addition !!	 bool inTree; //extra addition !!} ARC; 	GRAPH* graphCreate           (int  (*compare) (void* argu1, void* argu2));GRAPH* graphDestroy (GRAPH* graph);void graphInsVrtx   (GRAPH* graph, void*  dataInPtr);int graphDltVrtx    (GRAPH* graph, void*  dltKey);int graphInsArc     (GRAPH* graph, void*  pFromKey,int cost , void*  pToKey);int graphDltArc     (GRAPH* graph, void*  pFromKey, void*  pToKey);int graphRetrVrtx   (GRAPH* graph, void*  pKey, void** pDataOut);int graphFrstArc    (GRAPH* graph, void*  pKey, void** pDataOut);void graphDpthFrst  (GRAPH* graph, void (*process) (void* dataPtr));void graphBrdthFrst (GRAPH* graph, void (*process) (void* dataPtr));bool graphEmpty (GRAPH* graph);bool graphFull  (GRAPH* graph);int  graphCount (GRAPH* graph);void traverse(GRAPH* graph);void shortestPath(GRAPH* graph);GRAPH* graphCreate (int (*compare)                          (void* argu1, void* argu2)){//	Local Declarations 	GRAPH* graph;//	Statements 	graph = (GRAPH*) malloc (sizeof (GRAPH));	if (graph)		{		 graph->first   = NULL;		 graph->count   = 0;		 graph->compare = compare;		} // if 	return graph;}	// graphCreate bool graphEmpty (GRAPH* graph){	return (graph->count == 0);}	// graphEmpty bool graphFull (GRAPH* graph){//	Local Declarations 	VERTEX* newPtr;	//	Statements 	newPtr = (VERTEX*)malloc(sizeof (VERTEX));	if (newPtr)		{		 free (newPtr);		 return false;		} // if 	else	     return true;}	// graphFull int graphCount (GRAPH* graph){	return (graph->count);}	// graphCount int graphRetrVrtx (GRAPH* graph, void* keyPtr, void** pDataOut){//	Local Declarations     VERTEX* walkPtr;//	Statements 	if (!graph->first)	    return -2;		walkPtr = graph->first;	while (walkPtr && (graph->compare	                    (keyPtr, walkPtr->dataPtr) > 0))	    walkPtr = walkPtr->pNextVertex;	if(walkPtr == NULL)  //it's not in vertex list.  !!		return -2;		if (graph->compare(keyPtr, walkPtr->dataPtr) == 0)	   {	    *pDataOut = walkPtr->dataPtr;	    return 1;	   } // if 	else{				return -2;	}}	// graphRetrVrtx  int graphFrstArc (GRAPH* graph, void* keyPtr, void** pDataOut){//	Local Declarations     VERTEX* walkPtr;    ARC*    toPtr;//	Statements 	if (!graph->first)	    return -2;		walkPtr = graph->first;	while (walkPtr && (graph->compare	                    (keyPtr, walkPtr->dataPtr) > 0))	    walkPtr = walkPtr->pNextVertex;	if (graph->compare(keyPtr, walkPtr->dataPtr) == 0)	   {	    if (walkPtr->pArc)	       {	        toPtr     = walkPtr->pArc;	        *pDataOut = toPtr->destination->dataPtr;	        return 1;	       } // if walkPtr 	    else	        return -3;	   } // if found 	else	   return -2;}	// void graphInsVrtx (GRAPH* graph, void* dataInPtr){//	Local Definitions 	VERTEX* newPtr;	VERTEX* locPtr;	VERTEX* predPtr;	//	Statements 	newPtr = (VERTEX*)malloc(sizeof (VERTEX));	if (newPtr)	   {	    newPtr->pNextVertex  = NULL;	    newPtr->dataPtr      = dataInPtr;	    newPtr->inDegree     = 0;	    newPtr->outDegree    = 0;	    newPtr->processed    = 0;	    newPtr->pArc         = NULL;	    (graph->count)++;	   } // if malloc	 else	   {	    printf("Overflow error 100\a\n");	    exit (100);	   }	// Now find insertion point 	locPtr = graph->first;	if (!locPtr)	    // Empty graph. Insert at beginning 	    graph->first = newPtr;	else	   {	    predPtr = NULL;	    while (locPtr && (graph->compare	                     (dataInPtr, locPtr->dataPtr) > 0))	       {	        predPtr = locPtr;	        locPtr  = locPtr->pNextVertex;	       } // while 	    if (!predPtr)	        // Insert before first vertex 	        graph->first = newPtr;	    else	        predPtr->pNextVertex = newPtr;	    newPtr->pNextVertex = locPtr;	   } // else	return;}  // graphInsVrtx int graphDltVrtx (GRAPH* graph, void* dltKey){//	Local Definitions 	VERTEX* predPtr;	VERTEX* walkPtr;//	Statements 	if (!graph->first)	    return -2;	// Locate vertex to be deleted 	predPtr = NULL;	walkPtr = graph->first;	while (walkPtr	       && (graph->compare(dltKey, walkPtr->dataPtr) > 0))	   {	    predPtr = walkPtr;	    walkPtr = walkPtr->pNextVertex;	   } // walkPtr && 	if (!walkPtr 	  || graph->compare(dltKey, walkPtr->dataPtr) != 0)	   return -2;	   	// Found vertex. Test degree 	if ((walkPtr->inDegree > 0) || (walkPtr->outDegree > 0))	    return -1;		// OK to delete 	if (!predPtr)	    graph->first         = walkPtr->pNextVertex;	else	    predPtr->pNextVertex = walkPtr->pNextVertex;	--graph->count;	free(walkPtr);	return 1;}  // graphDltVrtx int graphInsArc (GRAPH* graph, void* pFromKey,int cost , void* pToKey) //extra cost !!{//	Local Definitions 	ARC*    newPtr;	ARC*    arcPredPtr;	ARC*    arcWalkPtr;	VERTEX* vertFromPtr;	VERTEX* vertToPtr;//	Statements 	newPtr = (ARC*)malloc(sizeof(ARC));	newPtr->cost = cost; //extra cost !!		if (!newPtr)	   return (-1);	// Locate source vertex 	vertFromPtr = graph->first;	while (vertFromPtr && (graph->compare(pFromKey,	                       vertFromPtr->dataPtr) > 0))	   {	    vertFromPtr = vertFromPtr->pNextVertex;	   } // while vertFromPtr && 	if (!vertFromPtr || (graph->compare(pFromKey,	                     vertFromPtr->dataPtr) != 0))	   return (-2);		// Now locate to vertex 	vertToPtr   = graph->first;	while (vertToPtr 	       && graph->compare(pToKey, vertToPtr->dataPtr) > 0)	   {	    vertToPtr   = vertToPtr->pNextVertex;	   } // while vertToPtr && 	if (!vertToPtr 	|| (graph->compare(pToKey, vertToPtr->dataPtr) != 0))	   return (-3);	   	// From and to vertices located. Insert new arc 	++vertFromPtr->outDegree;	++vertToPtr  ->inDegree;	newPtr->destination = vertToPtr;	if (!vertFromPtr->pArc)	   {	    // Inserting first arc for this vertex 	    vertFromPtr->pArc = newPtr;	    newPtr-> pNextArc = NULL;	    return 1;	   } // if new arc 		// Find insertion point in adjacency (arc) list 	arcPredPtr = NULL;	arcWalkPtr = vertFromPtr->pArc;	while (arcWalkPtr	       && graph->compare(pToKey,	                 arcWalkPtr->destination->dataPtr) >= 0)	   {	    arcPredPtr = arcWalkPtr;	    arcWalkPtr = arcWalkPtr->pNextArc;	   } // arcWalkPtr && 		if (!arcPredPtr)	    // Insertion before first arc 	    vertFromPtr->pArc    = newPtr;	else	    arcPredPtr->pNextArc = newPtr;	newPtr->pNextArc = arcWalkPtr;    return 1;}	// graphInsArc int graphDltArc (GRAPH* graph,                  void* fromKey, void* toKey){//	Local Definitions 	VERTEX* fromVertexPtr;	VERTEX* toVertexPtr;	ARC*    preArcPtr;	ARC*    arcWalkPtr;//	Statements 	if (!graph->first)	    return -2;	// Locate source vertex 	fromVertexPtr = graph->first;	while (fromVertexPtr && (graph->compare(fromKey,	                         fromVertexPtr->dataPtr) > 0))	    fromVertexPtr = fromVertexPtr->pNextVertex;	if (!fromVertexPtr || graph->compare(fromKey,	                          fromVertexPtr->dataPtr) != 0)	   return -2;	   	// Locate destination vertex in adjacency list 	if (!fromVertexPtr->pArc)	    return -3;		preArcPtr = NULL;	arcWalkPtr = fromVertexPtr->pArc;	while (arcWalkPtr && (graph->compare(toKey,	               arcWalkPtr->destination->dataPtr) > 0))	   {	    preArcPtr  = arcWalkPtr;	    arcWalkPtr = arcWalkPtr->pNextArc;	   } // while arcWalkPtr && 	if (!arcWalkPtr || (graph->compare(toKey,	               arcWalkPtr->destination->dataPtr) != 0))	    return -3;	toVertexPtr = arcWalkPtr->destination;		// from, toVertex & arcPtr located. Delete arc 	--fromVertexPtr->outDegree;     	--toVertexPtr -> inDegree;	if (!preArcPtr)	    // Deleting first arc 	    fromVertexPtr->pArc  = arcWalkPtr->pNextArc;	else	    preArcPtr->pNextArc = arcWalkPtr->pNextArc;	free (arcWalkPtr);	return 1;}  // graphDltArc void graphDpthFrst (GRAPH* graph,                     void (*process) (void* dataPtr)){ // Local Definitions 	bool    success;	VERTEX* walkPtr;	VERTEX* vertexPtr;	VERTEX* vertToPtr;	STACK * stack;	ARC*    arcWalkPtr;	// Statements 	if (!graph->first)	    return;	// Set processed flags to not processed 	walkPtr = graph->first;	while (walkPtr)	   {	    walkPtr->processed = 0;	    walkPtr            = walkPtr->pNextVertex;	   } // while 		// Process each vertex in list 	stack = createStack ();	walkPtr = graph->first;	while (walkPtr)	  {	   if (walkPtr->processed < 2)	     {	      if (walkPtr->processed < 1)	        {	         // Push & set flag to pushed 	         success = pushStack (stack, walkPtr);	         if (!success)	             printf("\aStack overflow 100\a\n"),	                   exit (100); 	            	         walkPtr->processed = 1;	        } // if processed < 1 	     } // if processed < 2 	   // Process descendents of vertex at stack top 	   while (!emptyStack (stack))	     {	      vertexPtr = (VERTEX*)popStack(stack);	      process (vertexPtr->dataPtr);	      vertexPtr->processed = 2;	        	      // Push all vertices from adjacency list 	      arcWalkPtr = vertexPtr->pArc;	      while (arcWalkPtr)	        {	         vertToPtr = arcWalkPtr->destination;	         if (vertToPtr->processed == 0)	           {	            success = pushStack(stack, vertToPtr);	            if (!success)	              printf("\aStack overflow 101\a\n"),	                  exit (101);	            vertToPtr->processed = 1;	           } // if vertToPtr 	         arcWalkPtr = arcWalkPtr->pNextArc;	        } // while pWalkArc 	           	     } // while !emptyStack 	   walkPtr = walkPtr->pNextVertex;	  } // while walkPtr	destroyStack(stack); 	return;} // graphDpthFrstvoid graphBrdthFrst (GRAPH* graph,                      void (*process) (void* dataPtr)){//	Local Definitions 	bool    success;	VERTEX* walkPtr;	VERTEX* vertexPtr;	VERTEX* vertToPtr;	QUEUE*  queue;		ARC*    arcWalkPtr;	//	Statements 	if (!graph->first)	    return; 	// Set processed flags to not processed 	walkPtr = graph->first;	while (walkPtr)	   {	    walkPtr->processed = 0;	    walkPtr            = walkPtr->pNextVertex;	   } // while 		// Process each vertex in list 	queue = createQueue ();	walkPtr = graph->first;	while (walkPtr)	   {	    if (walkPtr->processed < 2)	       {	        if (walkPtr->processed < 1)	           {	            // Enqueue & set flag to queue 	            success = enqueue(queue, walkPtr);	            if (!success)	               printf("\aQueue overflow 100\a\n"),	               exit (100);	            walkPtr->processed = 1;	           } // if processed < 1 	       } // if processed < 2 	    // Process descendents of vertex at que frnt 	    while (!emptyQueue (queue))	       {	        dequeue(queue, (void**)&vertexPtr);	        process (vertexPtr->dataPtr);	        vertexPtr->processed = 2;	        	        // Enqueue vertices from adjacency list 	        arcWalkPtr = vertexPtr->pArc;	        while (arcWalkPtr)	          {	           vertToPtr = arcWalkPtr->destination;	           if (vertToPtr->processed == 0)	             {	              success = enqueue(queue, vertToPtr);	              if (!success)	                printf("\aQueue overflow 101\a\n"),	                   exit (101);	              vertToPtr->processed = 1;	             } // if vertToPtr 	           arcWalkPtr = arcWalkPtr->pNextArc;	          } // while pWalkArc 	       } // while !emptyQueue 	    walkPtr = walkPtr->pNextVertex;	   } // while walkPtr 	destroyQueue(queue); 	return; } // graphBrdthFrst  void traverse(GRAPH* graph){	VERTEX *nowVertex;		nowVertex = graph->first;		while(nowVertex){		printf("vertex:%s\n", (char*)nowVertex->dataPtr);					ARC *nowArc;		nowArc = nowVertex->pArc;		while(nowArc){			printf("\tArc(dest.):%s, cost:%d\n", (char*)nowArc->destination->dataPtr, nowArc->cost);			nowArc = nowArc->pNextArc;		}				nowVertex = nowVertex->pNextVertex;	}} void shortestPath(GRAPH* graph){	VERTEX *nowVertex;	ARC *nowArc;	bool treeComplete;		if(graph == NULL)		return ;		//------------initialize---------------		nowVertex = graph->first;	while(nowVertex != NULL){		nowVertex->inTree = false;		nowVertex->pathLength = INT_MAX;		nowArc = nowVertex->pArc;		while(nowArc != NULL){			nowArc->inTree = false;			nowArc = nowArc->pNextArc;		}		nowVertex = nowVertex->pNextVertex;			}	//--------------end-------------------		nowVertex = graph->first;	nowVertex->inTree = true;	nowVertex->pathLength = 0;		 	treeComplete = false;	while(!treeComplete){		char *beginVertex;		ARC *allVertex_newEdge;		int allVertex_newPathLen;		treeComplete = true;		allVertex_newEdge = NULL;		allVertex_newPathLen = INT_MAX;				nowVertex = graph->first;		while(nowVertex){			ARC *oneVertex_minEdge;			int oneVertex_minEdgeLen;						oneVertex_minEdge = NULL;			oneVertex_minEdgeLen = INT_MAX;									if(nowVertex->inTree && nowVertex->outDegree > 0){							nowArc = nowVertex->pArc;				while(nowArc){										if(!nowArc->destination->inTree){						treeComplete = false;						if(nowArc->cost < oneVertex_minEdgeLen){							oneVertex_minEdgeLen = nowArc->cost;							oneVertex_minEdge = nowArc;						}					}					nowArc = nowArc->pNextArc;				}												if(oneVertex_minEdge != NULL){					if(nowVertex->pathLength + oneVertex_minEdgeLen < allVertex_newPathLen){						beginVertex = (char*)nowVertex->dataPtr;						allVertex_newPathLen = nowVertex->pathLength + oneVertex_minEdgeLen;						allVertex_newEdge = oneVertex_minEdge;					}				}			}			nowVertex = nowVertex->pNextVertex;		}								if(allVertex_newEdge != NULL){			printf("origin:%-2s\tdest:%-4s\tcost:%-3d\n", beginVertex, allVertex_newEdge->destination->dataPtr, allVertex_newEdge->cost);			allVertex_newEdge->inTree = true;			allVertex_newEdge->destination->inTree = true;			allVertex_newEdge->destination->pathLength = allVertex_newPathLen;		}	}}