/*	Header file for Binary Search Tree (BST). Contains	structural definitions and prototypes for BST.	   Written by:	   Date:*/#include <stdbool.h>#include <stdlib.h>//	Structure Declarations struct NODE{	 void*        dataPtr;	 struct NODE* left;	 struct NODE* right;	 bool rightThread;};struct BST_TREE{	int   count;	int  (*compare) (void* argu1, void* argu2);	struct NODE*  root;} ;	//	Prototype Declarations struct BST_TREE* BST_Create(int (*compare) (void* argu1, void* argu2));struct BST_TREE* BST_Destroy(struct BST_TREE* tree);bool  BST_Insert   (struct BST_TREE* tree, void* dataPtr);bool  BST_Delete   (struct BST_TREE* tree, void* dltKey);void BST_Thread(struct BST_TREE* tree, void (*process)(void* dataPtr));struct NODE* createThread (struct NODE* root);bool BST_Empty (struct BST_TREE* tree);bool BST_Full  (struct BST_TREE* tree);int  BST_Count (struct BST_TREE* tree);static struct NODE* _insert(struct BST_TREE* tree, struct NODE* root, struct NODE* newPtr); static struct NODE* _delete(struct BST_TREE* tree, struct NODE* root, void* dataPtr, bool* success);static void* _retrieve(struct BST_TREE* tree, void* dataPtr, struct NODE* root);void _traverse (struct NODE* root, void (*process) (void* dataPtr), struct STACK* threadStack);static void _destroy (struct NODE* root);struct BST_TREE* BST_Create         (int  (*compare) (void* argu1, void* argu2)){//	Local Definitions 	struct BST_TREE* tree;//	Statements 	tree = (struct BST_TREE*) malloc (sizeof (struct BST_TREE));	if (tree)	   {	    tree->root    = NULL;	    tree->count   = 0;	    tree->compare = compare;	   } // if 	return tree;}	// BST_Create bool BST_Insert (struct BST_TREE* tree, void* dataPtr){//	Local Definitions 	struct NODE* newPtr;//	Statements 	newPtr = (struct NODE*)malloc(sizeof(struct NODE));	if (!newPtr)	   return false;		newPtr->right   = NULL;	newPtr->left    = NULL;	newPtr->dataPtr = dataPtr;	newPtr->rightThread = false;	   	if (tree->count == 0)	    tree->root  =  newPtr;	else	    _insert(tree, tree->root, newPtr);	    	(tree->count)++;	return true;}  // BST_Insert struct NODE* _insert (struct BST_TREE* tree, struct NODE* root, struct NODE* newPtr){      //	Statements 	if (!root)	   // if NULL tree 	   return newPtr; 	// Locate null subtree for insertion 	if (tree->compare(newPtr->dataPtr, 	                  root->dataPtr) < 0)	   {	    root->left = _insert(tree, root->left, newPtr);	    return root; 	   } // new < node 	else 	   // new data >= root data 	   {	    root->right = _insert(tree, root->right, newPtr);	    return root;	     } // else new data >= root data 	return root;}	// _insert bool BST_Delete (struct BST_TREE* tree, void* dltKey){//	Local Definitions 	bool  success;	struct NODE* newRoot;	//	Statements 	newRoot = _delete (tree, tree->root, dltKey, &success);	if (success)	   {	    tree->root = newRoot;	    (tree->count)--;	    if (tree->count == 0)	        // Tree now empty 	        tree->root = NULL;	   } // if 	return success;}  // BST_Deletestruct NODE*  _delete (struct BST_TREE* tree,    struct NODE* root,                 void*     dataPtr, bool* success){// Local Definitions 	struct NODE* dltPtr;	struct NODE* exchPtr;	struct NODE* newRoot;	void* holdPtr;//	Statements 	if (!root)	   {	    *success = false;	    return NULL;	   } // if 		if (tree->compare(dataPtr, root->dataPtr) < 0)	     root->left  = _delete (tree,    root->left, 	                            dataPtr, success);	else if (tree->compare(dataPtr, root->dataPtr) > 0)	     root->right = _delete (tree,    root->right, 	                            dataPtr, success);	else	    // Delete node found--test for leaf node 	    {	     dltPtr = root;	     if (!root->left)	         // No left subtree 	         {	          free (root->dataPtr);       // data memory	          newRoot = root->right;	          free (dltPtr);              // BST Node	          *success = true;	          return newRoot;             // base case 	         } // if true 	     else	         if (!root->right)	             // Only left subtree 	             {	              newRoot = root->left;	              free (dltPtr);	              *success = true;	              return newRoot;         // base case 	            } // if 	         else	             // Delete Node has two subtrees 	             {	              exchPtr = root->left;	              // Find largest node on left subtree	              while (exchPtr->right)	                  exchPtr = exchPtr->right;	              // Exchange Data 	              holdPtr          = root->dataPtr;	              root->dataPtr    = exchPtr->dataPtr;	              exchPtr->dataPtr = holdPtr;	              root->left       = 	                 _delete (tree,   root->left, 	                          exchPtr->dataPtr, success);	             } // else 	    } // node found 	return root; }	// _delete void* BST_Retrieve  (struct BST_TREE* tree, void* keyPtr){//	Statements 	if (tree->root)	 {	    return _retrieve (tree, keyPtr, tree->root);             } 	else	    return NULL;}	// BST_Retrieve void* _retrieve (struct BST_TREE* tree, 	              void* dataPtr, struct NODE* root){//	Statements 	if (root)	    {	     if (tree->compare(dataPtr, root->dataPtr) < 0)	         return _retrieve(tree, dataPtr, root->left);	     else if (tree->compare(dataPtr, root->dataPtr) > 0)	         return _retrieve(tree, dataPtr, root->right);	     else	         // Found equal key 	         return root->dataPtr;	    }  // if root 	else	    // Data not in tree 	    return NULL;}	// _retrieve struct NODE* createThread (struct NODE* root) {	if(root == NULL)		return NULL;	if(root->left == NULL && root->right == NULL)  //leaf node		return root;					if(root->left != NULL && root->right == NULL) //get leaftleaf		return createThread(root->left);	else if(root->right != NULL && root->left == NULL) //get rightleaf		return createThread(root->right);			if(root->right != NULL){		struct NODE* leftleaf;		leftleaf = createThread(root->left);		leftleaf->right = root->right;		leftleaf->rightThread = true;	}	return createThread(root->right);}bool BST_Empty (struct BST_TREE* tree){//	Statements 	return (tree->count == 0);}	// BST_Empty bool BST_Full (struct BST_TREE* tree){//	Local Definitions 	struct NODE* newPtr;	//	Statements 	newPtr = (struct NODE*)malloc(sizeof (*(tree->root)));	if (newPtr)	   {	    free (newPtr);	    return false;	   } // if 	else	     return true;}	// BST_Full int BST_Count (struct BST_TREE* tree){//	Statements 	return (tree->count);}	// BST_Count struct BST_TREE* BST_Destroy (struct BST_TREE* tree) {//	Statements 	if (tree)		_destroy (tree->root);			// All nodes deleted. Free structure 	free (tree);	return NULL;}	// BST_Destroy void _destroy (struct NODE* root){//	Statements 	if (root)	   {	    _destroy (root->left);	    free (root->dataPtr);	    _destroy (root->right);	    free (root);	   } // if 	return;}	// _destroyvoid BST_Thread(struct BST_TREE* tree, void (*process)(void* dataPtr)){	createThread(tree->root);	struct NODE *node;		node = tree->root;		while(true){		if(node == NULL)			break;				process(node->dataPtr);		if(node->rightThread){			node = node->right;		}		else			node = node->left;	}}